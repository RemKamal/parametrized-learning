/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TMVAWrapper.h" 
#include "RooAbsReal.h" 

#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 


#include <cstdlib>
#include <vector>
#include <iostream>
#include <map>
#include <string>

#include "TFile.h"
#include "TNtuple.h"
#include "TTree.h"
#include "TString.h"
#include "TSystem.h"
#include "TROOT.h"
#include "TStopwatch.h"

#if not defined(__CINT__) || defined(__MAKECINT__)
#include "TMVA/Tools.h"
#include "TMVA/Reader.h"
#endif

ClassImp(TMVAWrapper) 


void TMVAWrapper::findVariables(TXMLNode *node)
{
  // is this one a Variable?
  if (!strcmp(node->GetNodeName(),"Variable") && node->HasAttributes())
    {

      // if so, get the name
      TList *atts = node->GetAttributes();
      TXMLAttr *ob = (TXMLAttr*)atts->FindObject("Label");
      std::cout << "   @@@@ found feature " << ob << " " << ob->GetValue() <<  std::endl;
      names.push_back(ob->GetValue());
    }

  // recursively explore siblings and children
  if (node->HasChildren()) findVariables(node->GetChildren());
  if (node->HasNextNode()) 
    findVariables(node->GetNextNode());
}

void TMVAWrapper::getListOfVars(char weights[100])
{
  num_features=0;
  names.clear();
  
  // set up the parser
  TDOMParser *parser = new TDOMParser();
  parser->SetValidate(false);
  parser->ParseFile(weights);

  // get the root of the XML tree
  TXMLDocument *doc = parser->GetXMLDocument();
  TXMLNode *node = doc->GetRootNode();
  
  // explore it recursively, looking for variables
  findVariables(node);

  num_features=names.size();
}



//using namespace TMVA;

/* update to parse XML for expected variables
  <Variables NVar="2">
    <Variable VarIndex="0" Expression="x" Label="x" Title="mass" Unit="units" Internal="x" Type="F" Min="-5.79654074e+00" Max="4.99505901e+00"/>
    <Variable VarIndex="1" Expression="alpha" Label="alpha" Title="alpha" Unit="units" Internal="alpha" Type="F" Min="-2.00000000e+00" Max="2.00000000e+00"/>
  </Variables>

*/


/*
 TMVAWrapper::TMVAWrapper(const char *name, const char *title, 
                        RooAbsReal& _features, RooAbsReal& _param) :
   RooAbsReal(name,title), 
   features("features","features",this,_features),
   param("param","param",this,_param)
 { 
   TMVA::Tools::Instance();
   reader = new TMVA::Reader( "!Color:!Silent" );    

   // Create a set of variables and declare them to the reader
   // - the variable names MUST corresponds in name and type to those given in the weight file(s) used
   reader->AddVariable( "x", &x);
   reader->AddVariable( "alpha", &alpha);

   // --- Book the MVA methods

   TString dir    = "weights/";
   TString prefix = "TMVARegression";

   // Book method(s)
   TString methodName = "MLP method";
   const TString weightfile = "TMVARegression_alphavary.root_MLP.weights.xml";
   reader->BookMVA( methodName, weightfile ); 

 } 
*/

TMVAWrapper::TMVAWrapper(const char *name, const char *title,RooArgList &ral,char weights_in[1000]):
  RooAbsReal(name,title),
  _actualVars("actualVars","useless title",this)
 { 
   std::cout << "Constructor!" << std::endl;

   _actualVars.add(ral);
   
   TMVA::Tools::Instance();
   reader = new TMVA::Reader( "!Color:!Silent" );    

   strcpy(weights,weights_in);

   getListOfVars(weights);

   for (int i=0;i<num_features;i++)
     {
       std::cout << " adding variable " << names[i] <<std::endl;
       _rab[i] = dynamic_cast<RooAbsReal*>(_actualVars.find(names[i]));
       std::cout << " in actualvars? " << _rab[i] << std::endl;
       reader->AddVariable(names[i],&local_features[i]);
     }

   // --- Book the MVA methods

   TString dir    = "weights/";
   TString prefix = "TMVARegression";

   // Book method(s)
   TString methodName = "MLP method";
   reader->BookMVA( methodName, weights);
 } 

 TMVAWrapper::TMVAWrapper(const TMVAWrapper& other, const char* name) :  
   RooAbsReal(other,name),
   _actualVars("actualVars",this,other._actualVars)
 { 
   
  //    std::cout << "Copy constructor! " << name << std::endl;
      std::cout << "Copy constructor! " << std::endl;
    reader=NULL;
    for (int i=0;i<10;i++)
       _rab[i] = NULL;



   TMVA::Tools::Instance();
   reader = new TMVA::Reader( "!Color:!Silent" );    
   
   // get feature list from other 
   strcpy(weights,other.weights);
   num_features = other.num_features;
   names.clear();
   for (int i=0;i<num_features;i++)
     names.push_back(other.names[i]);

   // register them
   for (int i=0;i<num_features;i++)
     {
       _rab[i] = other._rab[i];
       std::cout << "Adding variable " << names[i] << " in " << _rab[i] << std::endl;
       reader->AddVariable(names[i],&local_features[i]);
     }

   // --- Book the MVA methods

   TString dir    = "weights/";
   TString prefix = "TMVARegression";

   // Book method(s)
   TString methodName = "MLP method";
   reader->BookMVA( methodName, other.weights ); 

 } 


 Double_t TMVAWrapper::evaluate() const 
 { 

   for (int i=0;i<num_features;i++)
     {
       //       std::cout << " loading feature " << names[i] << " from " << _rab[i] <<std::endl;

       
       if (_rab[i])
	 {
//     local_features[i] = _rab[i]->getVal();
         local_features[i] = ((RooAbsReal*)_actualVars.at(i))->getVal();
	   std::cout << " ( " << names[i] << " = " << local_features[i] << ") ";
	 }
       else
	 {
	   std::cout << " !! Error, no variable " << names[i] << " in arglist" << std::endl;
	 }
     }

   Float_t val = (reader->EvaluateRegression("MLP method"))[0];
   std::cout << "  --> val = " << val <<std::endl;

   return val ; 
 } 

